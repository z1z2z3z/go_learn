**定义变量: **var 变量名 变量类型     行尾无需分号  例:var age int   var a,b int   ;    var a = 1      var  （a int  '换行' b  string）  常量不能用 `:=` 语法声明。var a [n]T  :表示拥有n个T类型的值的数组  [6]int{2, 3, 5, 7, 11, 13}

变量命名遵循驼峰命名法:首个单词小写,其他新单词大写   newData

**基本类型:**bool string int(........) uint .......     其默认值为: int为0  float为0.0  bool为false string为空字符串 指针为nll       所有的内存在go中都是经过初始化的

**输出:**  Printf("%T",变量)  //输出变量类型   Printf("具体类型",对应变量)  //输出表量值   %d  int   %s  string 

Printf("Type: %T Value:%v\n",tobt,tobt)  输出:Type:对应类型  Value:对应的值  换行

简短格式(不能给类型;需要给出具体值;函数内): i := 1   这种定义变量的方式只能在函数内部   局部变量  必须要使用     而全局变量  可以不被引用

**运行go**  遇到go build的exe文件  被某些杀毒流氓软件禁止导致无法正常运行     只需要将生成对exe对应对的文件夹添加到信任区便可以正常运行

**导出名:**如果一个名字以大写字母开头,那么它就是已导出的  例如:math.Pi     time.Now()

没有参数的 `return` 语句返回已命名的返回值。也就是 `直接` 返回     ❓x = sum * 4 / 9    函数的闭包    映射

1 << 100 将1左移100位来创建一个非常大的数字        //计算的时候需要相同的类型

if,for  条件里不需要加括号   if可以在条件表达式前执行一个简单的语句  作用域在if..else..内

(第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本.)for i, v:=range 数组 {}

##  defer

defer 语句会将函数推迟到外层函数返回之后执行。

推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。//会立即求值,但不会被调用

推迟函数进入defer栈   后进先出

## 指针

Go 拥有指针。指针保存了值的内存地址。

类型 `*T` 是指向 `T` 类型值的指针。其零值为 `nil`。

&操作符会生成一个指向操作数的指针(保存了值的内存地址)  例如:p:=&i(内存地址)  *p(值)     

结构体指针可以进行隐式间接引用 p := &v(结构体)  p.x(结构体里的一个元素)   type  (名字)name  struct {X,Y int}  v1= (名字)name{1,2}

**数组**：[]T表示一个元素类型为T的切片var s []int = (一个已有的数组)primes[1:4]  low--->high  包括high-1  改变切片的值  对应数组的值会被改变    长度是当前个数  容量是底层元素个数

```
s := []struct {
		i int
		b bool
	}{
		{2, true},
		{3, false},
		{5, true},
		{7, true},
		{11, false},
		{13, true},
	}   //前面是结构体
	
	输出:[{2 true} {3 false} {5 true} {7 true} {11 false} {13 true}]
```

信道是带有类型的管道    go程  通过信道来将不同go程得出的结果联系起来

## 带缓冲的信道,安全队列(先进先出)

信道可以是 **带缓冲的**。将缓冲长度作为第二个参数提供给 `make` 来初始化一个带缓冲的信道：

```go
ch := make(chan int, 100)
```

仅当信道的缓冲区填满后，向其发送数据时才会阻塞。当缓冲区为空时，接受方会阻塞。   for range将其中止需要发送者需要关闭信道

**无缓冲的信道在取消息和存消息的时候都会挂起当前的goroutine，除非另一端已经准备好。**

比如以下的main函数和foo函数:

```go
var ch chan int = make(chan int)

func foo() {
    ch <- 0  // 向ch中加数据，如果没有其他goroutine来取走这个数据，那么挂起foo, 直到main函数把0这个数据拿走
}

func main() {
    go foo()
    <- ch // 从ch取数据，如果ch中还没放数据，那就挂起main线，直到foo函数中放数据为止
}
```
